package io.github.mal32.endergames.worlds.game;

import java.awt.*;

//
// IMPORTANT NOTE
//
// The following code is completely generated by AI and is not reviewed, just tested.
//
// IMPORTANT NOTE
//

public class GaussBlur {
  public static Color[][] gaussianBlurAndDim(
      Color[][] src, int size, int radius, double sigma, float dimFactor) {
    float[] kernel = buildGaussianKernel(radius, sigma);

    // Pass 1: horizontal
    float[] tmpR = new float[size * size];
    float[] tmpG = new float[size * size];
    float[] tmpB = new float[size * size];
    float[] tmpA = new float[size * size]; // -1 means: original src pixel was null

    for (int y = 0; y < size; y++) {
      int row = y * size;
      for (int x = 0; x < size; x++) {
        int idx = row + x;

        // Keep null pixels immutable (mask)
        if (src[y][x] == null) {
          tmpR[idx] = tmpG[idx] = tmpB[idx] = 0.0f;
          tmpA[idx] = -1.0f;
          continue;
        }

        float sumR = 0, sumG = 0, sumB = 0;
        float wSum = 0;

        for (int k = -radius; k <= radius; k++) {
          int xx = x + k;
          if (xx < 0 || xx >= size) continue;

          Color c = src[y][xx];
          if (c == null) continue;

          int a = c.getAlpha();
          if (a == 0) continue;

          float w = kernel[k + radius];
          // Weight by alpha so transparent pixels don't darken the blur
          float wa = w * (a / 255.0f);

          sumR += c.getRed() * wa;
          sumG += c.getGreen() * wa;
          sumB += c.getBlue() * wa;
          wSum += wa;
        }

        if (wSum > 0.0f) {
          tmpR[idx] = sumR / wSum;
          tmpG[idx] = sumG / wSum;
          tmpB[idx] = sumB / wSum;
        } else {
          tmpR[idx] = tmpG[idx] = tmpB[idx] = 0.0f;
        }

        // Normalize alpha by weights actually used
        float aWSum = 0;
        float aSum = 0;
        for (int k = -radius; k <= radius; k++) {
          int xx = x + k;
          if (xx < 0 || xx >= size) continue;

          Color c = src[y][xx];
          if (c == null) continue;

          float w = kernel[k + radius];
          aSum += c.getAlpha() * w;
          aWSum += w;
        }
        tmpA[idx] = (aWSum > 0.0f) ? (aSum / aWSum) : 0.0f;
      }
    }

    // Pass 2: vertical + dim + output
    Color[][] out = new Color[size][size];

    for (int x = 0; x < size; x++) {
      for (int y = 0; y < size; y++) {
        // Keep null pixels unchanged
        if (src[y][x] == null) {
          out[y][x] = null;
          continue;
        }

        float sumR = 0, sumG = 0, sumB = 0;
        float wSum = 0;

        float sumA = 0;
        float aWSum = 0;

        for (int k = -radius; k <= radius; k++) {
          int yy = y + k;
          if (yy < 0 || yy >= size) continue;

          int idx = yy * size + x;
          float a = tmpA[idx];

          // Skip cells that were null in source
          if (a < 0.0f) continue;
          if (a <= 0.0f) continue;

          float w = kernel[k + radius];
          float wa = w * (a / 255.0f);

          sumR += tmpR[idx] * wa;
          sumG += tmpG[idx] * wa;
          sumB += tmpB[idx] * wa;
          wSum += wa;

          sumA += a * w;
          aWSum += w;
        }

        if (wSum <= 0.0f || aWSum <= 0.0f) {
          out[y][x] = new Color(0, 0, 0, 0);
          continue;
        }

        int r = clamp255((int) ((sumR / wSum) * dimFactor));
        int g = clamp255((int) ((sumG / wSum) * dimFactor));
        int b = clamp255((int) ((sumB / wSum) * dimFactor));
        int a = clamp255((int) (sumA / aWSum));

        out[y][x] = new Color(r, g, b, a);
      }
    }

    return out;
  }

  private static float[] buildGaussianKernel(int radius, double sigma) {
    int size = radius * 2 + 1;
    float[] k = new float[size];

    double twoSigma2 = 2.0 * sigma * sigma;
    double sum = 0.0;

    for (int i = -radius; i <= radius; i++) {
      double v = Math.exp(-(i * i) / twoSigma2);
      k[i + radius] = (float) v;
      sum += v;
    }

    // normalize to sum=1
    for (int i = 0; i < size; i++) {
      k[i] = (float) (k[i] / sum);
    }
    return k;
  }

  private static int clamp255(int v) {
    return (v < 0) ? 0 : Math.min(255, v);
  }
}
